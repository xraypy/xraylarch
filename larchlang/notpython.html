
<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>10.9. Differences between Larch and Python &#8212; xraylarch 2025.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/larchdoc.css?v=dfcb3266" />
    
    <script src="../_static/documentation_options.js?v=865d4376"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="11. Reading and Writing Data" href="../data.html" />
    <link rel="prev" title="10.8. Builtin Functions" href="builtins.html" />

<script async src="https://badge.dimensions.ai/badge.js" charset="utf-8"></script>

<script type="text/x-mathjax-config">
   MathJax.Hub.Config({ "TeX": {Macros: {AA : "{\\unicode{x212B}}"}}, "HTML-CSS": {scale: 90}});
</script>


  </head><body>
<div style=" color: #c5daba;  text-align: left; height:65px; padding: 0px">
<table border=0>
  <tr>
    <td width=20%>
	<a href="../index.html">
	 <img src="../_static/larchcones.png" height=50px alt="larchcones"/></a>
    </td>
    <td width=75% padding=0>
      <font size=+2>
	<a href="../index.html" style="color:#772211">
	  Larch: Data Analysis Tools for X-ray Spectroscopy
	</a>
      </font>
    </td>
   </tr></table>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../data.html" title="11. Reading and Writing Data"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="builtins.html" title="10.8. Builtin Functions"
             accesskey="P">previous</a> |</li>
   <li>[<a href="../index.html"> Larch</a>|</li>
   <li><a href="../getting_started.html"> Getting Started</a>|</li>
   <li><a href="../xafs.html">XAFS Analysis</a>|</li>
   <li><a href="../xray.html">X-ray Databases</a>|</li>
   <li><a href="../xrf.html">XRF Analysis</a>|</li>

          <li class="nav-item nav-item-1"><a href="../larchlang.html" accesskey="U"><span class="section-number">10. </span>Larch Macro Language Tutorial</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">10.9. </span>Differences between Larch and Python</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">10.9. Differences between Larch and Python</a><ul>
<li><a class="reference internal" href="#code-block-ends">10.9.1. Code Block Ends</a></li>
<li><a class="reference internal" href="#groups-vs-modules">10.9.2. Groups vs Modules</a></li>
<li><a class="reference internal" href="#symbol-lookup-rules">10.9.3. Symbol Lookup Rules</a></li>
<li><a class="reference internal" href="#unimplemented-features">10.9.4. Unimplemented features</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="builtins.html"
                          title="previous chapter"><span class="section-number">10.8. </span>Builtin Functions</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="../data.html"
                          title="next chapter"><span class="section-number">11. </span>Reading and Writing Data</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/larchlang/notpython.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="differences-between-larch-and-python">
<span id="python-diffs-section"></span><h1><span class="section-number">10.9. </span>Differences between Larch and Python<a class="headerlink" href="#differences-between-larch-and-python" title="Link to this heading">¶</a></h1>
<p>Larch is based on and very similar to Python, but there are some very
important differences that need to be noted, especially for those familiar
with Python.  These differences are not here because we feel Python is
somehow inadequate or imperfect, but because Larch is intended as a
domain-specific-language.  The fact that Larch’s syntax is so close to
Python is really something of an implementation detail, so straying from
the “purity” of Python shouldn’t be seen as an allegation of imperfection
on either Larch’s or Python’s parts – they have different goals.  The
principle differences with Python are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Using ‘end*’ instead of significant white-space for code blocks.</p></li>
<li><p>Groups versus Modules</p></li>
<li><p>Changing the lookup rules for finding symbol names</p></li>
<li><p>Not implementing several python concepts, notably Class, and lambda.</p></li>
</ol>
</div></blockquote>
<p>Each of these is discussed in more detail below.</p>
<p>Some background and discussion of Larch implementation may help inform the
discussion below, and help describe many of the design decisions made in
Larch.  First and foremost, Larch is designed to be a domain-specific macro
language that makes heavy use of Python’s wonderful tools for processing
scientific data.  Having a macro language that was similar to Python was
not the primary goal.  The first version of Larch actually had much weaker
correspondance to Python.  It turned out that the implementation was much
easier and more robust when using syntax close to Python.</p>
<p>When larch code is run, the text is first <em>translated into Python code</em> and
then parsed by Python’s own  <em>ast</em> module which parses Python code into an
<em>abstract syntax tree</em> that is much more convenient for a machine to
execute.   As a brief description of what this module does, the statement:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">+</span><span class="n">c</span>
</pre></div>
</div>
<p>will be parsed and translated into something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Add</span><span class="p">(</span><span class="n">Name</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="n">Mult</span><span class="p">(</span><span class="n">Name</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="n">Call</span><span class="p">(</span><span class="n">Name</span><span class="p">(</span><span class="s1">&#39;sin&#39;</span><span class="p">),</span> <span class="n">Args</span><span class="p">([</span><span class="n">Mult</span><span class="p">(</span><span class="n">Num</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Name</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">))]))))</span>
</pre></div>
</div>
<p>Larch then walks through this tree, executing each Add, Mult, etc on its
arguments.  If you’ve ever done any text processing or thought about how a
compiler works, you’ll see that having this translation step done by proven
tools is a huge benefit.  For one thing, using Python’s own interpreter
means that Larch simply does not having parsing errors – any problem would
be translation of Larch code into Python, or in executing the compiled code
above.  This also makes the core code implementing Larch much easier (the
core functionality is fewer than 3000 lines of code).</p>
<p>Given this main implementation feature of Larch, you can probably see where
and how the differences with Python arise:</p>
<blockquote>
<div><ul class="simple">
<li><p>The Larch-to-Python translation step converts the ‘end*’ keywords into
significant whitespace (‘commenting out ‘endif’ etc if needed).</p></li>
<li><p>The lookup for symbols in <strong>Name(‘c’)</strong> is done at run-time, allowing
changes from the standard Python name lookup rules.</p></li>
<li><p>Unimplemented Python constructs (class, lambda, etc) are parsed, but</p></li>
</ul>
</div></blockquote>
<p>You can also see that Python’s syntax is followed very closely, so that the
translation from Larch-to-Python is minimal.</p>
<section id="code-block-ends">
<span id="id1"></span><h2><span class="section-number">10.9.1. </span>Code Block Ends<a class="headerlink" href="#code-block-ends" title="Link to this heading">¶</a></h2>
<p>Unlike Python, Larch does not use significant whitespace to define blocks.
There, that was easy.  Instead, Larch uses “end blocks”, of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">test</span><span class="p">:</span>
   <span class="o">&lt;</span><span class="n">block</span> <span class="n">of</span> <span class="n">statements</span><span class="o">&gt;</span>
<span class="n">endif</span>
</pre></div>
</div>
<p>Each of the Keywords <em>if</em>, <em>while</em>, <em>for</em>, <em>def</em>, and <em>try</em> must be matched
with a corresponding ‘end’ keyword: <em>endif</em>, <em>endwhile</em>, <em>endfor</em>,
<em>enddef</em>, and <em>endtry</em>.  You do not need an <em>endelse</em>, <em>endelif</em>,
<em>endexcept</em>, etc, as this is not ambiguous.</p>
<p>As a special note, you can place a ‘#’ in front of ‘end’. Note that this
means exactly 1 ‘#’ and exactly in front of ‘end’, so that ‘#endif’ is
allowed but not ‘####endif’ or ‘# endfor’.  This allows you to follow
Python’s indenting rules and write code that is valid Larch and valid
Python, which can be useful in translating code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="c1">#endfor</span>
</pre></div>
</div>
<p>This code is both valid Larch and valid Python.</p>
</section>
<section id="groups-vs-modules">
<h2><span class="section-number">10.9.2. </span>Groups vs Modules<a class="headerlink" href="#groups-vs-modules" title="Link to this heading">¶</a></h2>
<p>This is at least partly a semantic distinction.  Larch organizes data and
code into Groups – simple containers that hold data, functions, and other
groups.  These are implemented as a simple, empty class that is part of the
symbol table.</p>
</section>
<section id="symbol-lookup-rules">
<h2><span class="section-number">10.9.3. </span>Symbol Lookup Rules<a class="headerlink" href="#symbol-lookup-rules" title="Link to this heading">¶</a></h2>
<p>Looking up symbol names is a key feature of any language.  Python and Larch
both allow <em>namespaces</em> in which symbols can be nested into a heirarchy,
using a syntax of <strong>parent.child</strong>, with a dot (‘.’) separating the
components of the name.   Such parent/child relationships for symbol names
are used for modules (files of code), and object attributes.   Thus, one
could have data objects named:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cu_01</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">chi</span>
<span class="n">cu_02</span><span class="o">.</span><span class="n">path1</span><span class="o">.</span><span class="n">chi</span>
<span class="n">cu_03</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">chi</span>
</pre></div>
</div>
<p>Where the name <em>chi</em> is used repeatedly, but with different (and multiple)
parents.  The issue of name lookups is how to know what (if any) to use if
<em>chi</em> is specified without its parents names.</p>
<p>In Python, name lookups are quite straightforward and strict: “<em>local,
module</em>”. Here, <em>local</em> means “inside the current function or method” and
<em>module</em> means “inside the current module (file of code text)”.  More
specifically, each function or method and each module is given its own
namespace, and symbols are looked for first in the local namespace, and
then in the module namespace.  These rules are focused on <em>code</em> rather
than <em>data</em>, and leads to having a lot of “import” statements at the top of
python modules.  For example, to access the <code class="xref py py-func docutils literal notranslate"><span class="pre">sqrt()</span></code> function from the
numpy module, one typically does one of these:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>

<span class="k">def</span> <span class="nf">sqrt_array</span><span class="p">(</span><span class="n">npts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">sqrt_array</span><span class="p">(</span><span class="n">npts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>In both of these examples the numpy module is brought into the <em>module</em>
level namespace, either named as ‘numpy’ or renamed to ‘np’ (a common
convention in scientific python code).  Inside the function
<code class="xref py py-func docutils literal notranslate"><span class="pre">sqrt_array()</span></code>, the names ‘npts’ and ‘x’ are in the local namespace –
they are not available outside the function.  The functions <code class="xref py py-func docutils literal notranslate"><span class="pre">arange()</span></code>
and <code class="xref py py-func docutils literal notranslate"><span class="pre">sqrt()</span></code> are taken from the module-level namespace, using the name
as defined in the import statement.  A third alternative would be to
import only the names ‘sqrt’ and ‘arange’ into the modules namespace:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">arange</span>

<span class="k">def</span> <span class="nf">sqrt_array</span><span class="p">(</span><span class="n">npts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>For quick and dirty Python scripts, there is a tendency to use <cite>import *</cite>, as in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">def</span> <span class="nf">sqrt_array</span><span class="p">(</span><span class="n">npts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>which imports several hundred names into the module level namespace.  Many
experienced developers will tell you to avoid this like the plague.</p>
<p>In Larch, the general problem of how to lookup the names of objects
remains, but the rules are changed slightly.  Since Group objects are used
extensively throughout Larch exactly to provide namespaces as a way to
organize data, we might as well use them.  Instead of using <cite>import *</cite>,
Larch has a top-level group ‘_math’ in which it stores several hundred
names of functions, mostly from the numpy module.  It also uses top-level
groups ‘_sys’ and ‘_builtin’, which hold non-mathematical builtin functions
and data, and many plugins will add top-level groups (such as ‘_plotter’,
‘_xafs’, and ‘_xray’).  So, to access <code class="xref py py-func docutils literal notranslate"><span class="pre">sqrt()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">arange()</span></code> in
Larch, you could write <cite>_math.sqrt()</cite> and <cite>_math.arange()</cite>.  But you don’t
have to.</p>
<p>Symbol lookup in Larch uses a list of Groups which is searched for names.
This list of groups is held in _sys.searchGroups (which holds the group
names) and _sys.searchGroupObjects (which holds references to the groups
themselves).  These will be changed as the program runs.  They can be
changed dynamically, this is not encouraged (and can lead to Larch not
being able to work well).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.9.34: </span><cite>_sys.paramGroup</cite> is no longer used.</p>
</div>
<p>Larch also has 2 special variables that it uses to hold references to
groups that are <em>always</em> included in the search of names.  These are
‘_sys.localGroup’, which holds the group for a currently running function
while it is running; ‘_sys.moduleGroup’, which holds the namespace for a
module associated with a currently running function.</p>
</section>
<section id="unimplemented-features">
<h2><span class="section-number">10.9.4. </span>Unimplemented features<a class="headerlink" href="#unimplemented-features" title="Link to this heading">¶</a></h2>
<p>A domain-specific-language like Larch does not need to be as full-featured
as Python, so we left a few things out.  These include (this may not be an
exhaustive list):</p>
<blockquote>
<div><ul class="simple">
<li><p>eval – Larch <em>is</em> sort of a Python eval</p></li>
<li><p>lambda</p></li>
<li><p>class</p></li>
<li><p>global</p></li>
<li><p>generators, yield</p></li>
<li><p>decorators</p></li>
</ul>
</div></blockquote>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../data.html" title="11. Reading and Writing Data"
             >next</a> |</li>
        <li class="right" >
          <a href="builtins.html" title="10.8. Builtin Functions"
             >previous</a> |</li>
   <li>[<a href="../index.html"> Larch</a>|</li>
   <li><a href="../getting_started.html"> Getting Started</a>|</li>
   <li><a href="../xafs.html">XAFS Analysis</a>|</li>
   <li><a href="../xray.html">X-ray Databases</a>|</li>
   <li><a href="../xrf.html">XRF Analysis</a>|</li>

          <li class="nav-item nav-item-1"><a href="../larchlang.html" ><span class="section-number">10. </span>Larch Macro Language Tutorial</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">10.9. </span>Differences between Larch and Python</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright Matthew Newville, The University of Chicago, 2022.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>